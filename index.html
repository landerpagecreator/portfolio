
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Anas - App Developer & Creator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/retropix" rel="stylesheet">
    <style>
        * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color: transparent; }

        :root{
            --bg:#fafafa;
            --surface:#ffffff;
            --surface-hover:#f8f8f8;
            --surface-glass:rgba(255,255,255,0.92);
            --border:#eaeaea;
            --border-hover:#d0d0d0;
            --border-subtle:#f0f0f0;
            --text-primary:#111111;
            --text-secondary:#555555;
            --text-muted:#888888;
            --hover-bg:#f5f5f5;
            --shadow-sm:0 1px 2px rgba(0,0,0,.03), 0 2px 4px rgba(0,0,0,.02);
            --shadow-md:0 4px 12px rgba(0,0,0,.05), 0 2px 4px rgba(0,0,0,.03), 0 0 0 1px rgba(0,0,0,.02);
            --shadow-lg:0 8px 24px rgba(0,0,0,.08), 0 4px 8px rgba(0,0,0,.04), 0 0 0 1px rgba(0,0,0,.02);
            --shadow-xl:0 16px 48px rgba(0,0,0,.1), 0 8px 16px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.02);
            --shadow-glow:0 0 0 1px rgba(0,0,0,.03), 0 2px 8px rgba(0,0,0,.04);
            --accent-red: linear-gradient(135deg, #ff4444 0%, #dc2626 100%);
            --transition:all .2s cubic-bezier(.4,0,.2,1);
            --transition-bounce:all .4s cubic-bezier(.175,.885,.32,1.275);
            --border-radius:12px;
            --border-radius-lg:16px;
        }

        [data-theme="dark"]{
            --bg:#0f0f0f;
            --surface:#1a1a1a;
            --surface-hover:#222222;
            --surface-glass:rgba(20,20,20,0.95);
            --border:#2a2a2a;
            --border-hover:#3a3a3a;
            --border-subtle:#222222;
            --text-primary:#fafafa;
            --text-secondary:#a0a0a0;
            --text-muted:#606060;
            --hover-bg:#222222;
            --shadow-sm:0 1px 2px rgba(0,0,0,.2), 0 2px 4px rgba(0,0,0,.15);
            --shadow-md:0 4px 12px rgba(0,0,0,.3), 0 2px 4px rgba(0,0,0,.2), 0 0 0 1px rgba(255,255,255,.03);
            --shadow-lg:0 8px 24px rgba(0,0,0,.4), 0 4px 8px rgba(0,0,0,.25), 0 0 0 1px rgba(255,255,255,.03);
            --shadow-xl:0 16px 48px rgba(0,0,0,.5), 0 8px 16px rgba(0,0,0,.3), 0 0 0 1px rgba(255,255,255,.04);
            --shadow-glow:0 0 0 1px rgba(255,255,255,.05), 0 2px 8px rgba(0,0,0,.3);
        }

        html,body{ min-height:100vh; }
        body{
            font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
            background:var(--bg);
            color:var(--text-primary);
            line-height:1.6;
            transition:background .4s ease, color .3s ease;
            display:flex; align-items:center; justify-content:center; text-align:center;
            font-synthesis:none; text-rendering:optimizeLegibility;
            -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
            padding: 40px 20px;
        }

        .theme-toggle{
            position:fixed; top:24px; right:24px; width:52px; height:28px;
            background:var(--surface-glass); backdrop-filter:saturate(180%) blur(24px); -webkit-backdrop-filter:saturate(180%) blur(24px);
            border:1px solid var(--border); border-radius:100px;
            cursor:pointer; display:flex; align-items:center; padding:3px;
            transition: all .2s ease; z-index:1000; box-shadow:var(--shadow-md);
        }
        .theme-toggle:hover{ border-color:var(--border-hover); box-shadow:var(--shadow-lg); transform:scale(1.02); }
        .theme-toggle:active{ transform:scale(0.98); }
        .theme-toggle-circle{
            width:22px; height:22px; background:var(--text-primary); border-radius:50%;
            transition: all .35s cubic-bezier(.175,.885,.32,1.275); display:flex; align-items:center; justify-content:center;
            box-shadow: 0 1px 3px rgba(0,0,0,.15);
        }
        [data-theme="dark"] .theme-toggle-circle{ transform:translateX(24px); }

        .container{
            width:100%; max-width:900px; position:relative;
            display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:20px;
        }

        header{ margin-bottom:24px; text-align:center; opacity:0; animation:fadeInUp .8s cubic-bezier(.4,0,.2,1) forwards; position:relative; }
        .logo{
            width:88px; height:88px; margin:0 auto 20px; display:block;
            animation:float 5s ease-in-out infinite;
            transition: transform .3s cubic-bezier(.4,0,.2,1), filter .3s ease;
            filter: drop-shadow(var(--shadow-lg));
        }
        .logo:hover{ transform:scale(1.06) translateY(-2px); filter: drop-shadow(var(--shadow-xl)); }
        @keyframes float{ 0%, 100%{ transform:translateY(0px); } 50%{ transform:translateY(-8px); } }
        @keyframes fadeInUp{ from{opacity:0; transform:translateY(25px);} to{opacity:1; transform:translateY(0);} }

        h1{
            font-size:2.5rem; font-weight:700; margin-bottom:14px;
            letter-spacing:-.04em; color:var(--text-primary);
            position:relative; z-index:2;
            background: linear-gradient(180deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
        }

        .hero-statement{
            font-size:1.25rem; font-weight:500; margin-bottom:24px; color:var(--text-primary);
            letter-spacing:-.015em;
            position:relative; z-index:2;
        }
        .hero-statement .static{ color:var(--text-secondary); }
        .typing-wrapper{ display:inline-block; position:relative; }
        .typing-text{
            color:var(--text-primary); font-weight:600;
            background:linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip:text; -webkit-text-fill-color:transparent;
            background-clip:text;
        }
        .cursor{
            display:inline-block; width:2px; height:1.1em; background:var(--text-muted);
            margin-left:1px; vertical-align:text-bottom; border-radius:2px;
            animation:blink 1.1s ease-in-out infinite;
        }
        @keyframes blink{ 0%,40%{opacity:1;} 50%,100%{opacity:0;} }

        .tech-badges{ display:flex; gap:8px; justify-content:center; flex-wrap:wrap; position:relative; z-index:2; }
        .badge{
            padding:6px 12px; background:var(--surface); border:1px solid var(--border);
            border-radius:100px; font-size:.8rem; color:var(--text-secondary); font-weight:500;
            transition:var(--transition); letter-spacing:-.01em;
            display:inline-flex; align-items:center; gap:5px;
            box-shadow:var(--shadow-sm);
        }
        .badge svg{ width:13px; height:13px; flex-shrink:0; opacity:.8; }
        .badge:hover{ border-color:var(--border-hover); transform:translateY(-1px); box-shadow:var(--shadow-md); color:var(--text-primary); }
        .badge:hover svg{ opacity:1; }

        .divider{
            width:180px; height:1px;
            background:linear-gradient(90deg, transparent, var(--border-hover), transparent);
            margin: 32px auto 40px;
            opacity:0.6;
            position:relative; z-index:2;
        }

        .nav-container{
            display:flex; gap:14px; justify-content:center; flex-wrap:wrap; position:relative; z-index:2;
            opacity:0; animation:fadeInUp .8s cubic-bezier(.4,0,.2,1) .15s forwards;
        }
        .nav-item{ position:relative; }
        .nav-item.mobile-active .dropdown{ opacity:1; visibility:visible; transform:translateX(-50%) translateY(0); }

        .nav-button{
            padding:13px 22px; background:var(--surface); border:1px solid var(--border);
            border-radius:var(--border-radius); font-size:.875rem; color:var(--text-primary); cursor:pointer;
            transition: all .2s cubic-bezier(.4,0,.2,1), transform .25s cubic-bezier(.4,0,.2,1);
            display:inline-flex; align-items:center; gap:9px; text-decoration:none;
            font-weight:500; position:relative; box-shadow:var(--shadow-md); min-width:135px; justify-content:center;
            font-family:'Inter',-apple-system,BlinkMacSystemFont,sans-serif; letter-spacing:-.01em;
        }
        .nav-button svg{
            width:17px; height:17px; stroke:var(--text-secondary); stroke-width:1.75;
            transition: all .2s ease; flex-shrink:0;
        }
        .nav-button:hover{
            transform:translateY(-3px); box-shadow:var(--shadow-xl); border-color:var(--text-primary);
            background:var(--text-primary); color:var(--bg);
        }
        .nav-button:hover svg{ stroke:var(--bg); transform:scale(1.05); }
        .nav-button:active{ transform:translateY(-1px); transition-duration:.1s; }

        .youtube-badge{
            position:absolute; top:-10px; right:-10px; background:var(--accent-red); color:#fff;
            padding:4px 9px; border-radius:10px; font-weight:700; font-size:.68rem; min-width:22px; text-align:center;
            box-shadow: 0 4px 12px rgba(230, 0, 0, 0.3), 0 0 20px rgba(230, 0, 0, 0.15); z-index:2; border: 2px solid var(--bg);
            letter-spacing:.02em;
            animation: badgePulse 2.5s ease-in-out infinite;
        }
        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(230, 0, 0, 0.3), 0 0 20px rgba(230, 0, 0, 0.15); }
            50% { box-shadow: 0 4px 16px rgba(230, 0, 0, 0.45), 0 0 28px rgba(230, 0, 0, 0.25); }
        }

        .dropdown{
            position:absolute; bottom:calc(100% + 35px); left:50%;
            display:flex; flex-direction:column; gap:4px; opacity:0; visibility:hidden;
            transform:translateX(-50%) translateY(6px);
            transition:all .2s cubic-bezier(.4,0,.2,1); z-index:20;
            min-width:220px; background:var(--surface-glass); backdrop-filter:saturate(180%) blur(28px); -webkit-backdrop-filter:saturate(180%) blur(28px);
            border:1px solid var(--border); border-radius:var(--border-radius-lg); padding:8px;
            box-shadow:var(--shadow-xl);
        }
        .dropdown::before{
            content:''; position:absolute; bottom:-35px; left:0; right:0; height:35px;
        }
        .nav-item:hover .dropdown, .nav-item.snake-hover .dropdown{ opacity:1; visibility:visible; transform:translateX(-50%) translateY(0); }

        .dropdown-item{
            display:flex; align-items:center; gap:11px; padding:10px 12px; background:transparent; border:1px solid transparent;
            border-radius:10px; color:var(--text-primary); text-decoration:none;
            transition: all .15s ease; font-size:.85rem; text-align:left;
        }
        .dropdown-item:hover, .dropdown-item.snake-hover{ background:var(--hover-bg); border-color:var(--border-subtle); }
        .dropdown-item svg{ width:18px; height:18px; flex-shrink:0; stroke:var(--text-muted); stroke-width:1.75; transition: all .15s ease; }
        .dropdown-item:hover svg, .dropdown-item.snake-hover svg{ stroke:var(--text-primary); }
        .dropdown-item .item-text{ flex:1; }
        .dropdown-item strong{ display:block; font-weight:600; margin-bottom:1px; letter-spacing:-.01em; font-size:.84rem; }
        .dropdown-item small{ color:var(--text-muted); font-size:.75rem; line-height:1.35; }

        .social-links{ display:grid; grid-template-columns:1fr 1fr; gap:4px; }
        .social-link{
            padding:9px 11px; background:transparent; border:1px solid transparent; border-radius:10px;
            text-decoration:none; color:var(--text-secondary); transition: all .15s ease;
            font-size:.8rem; font-weight:500; letter-spacing:-.01em;
            display:flex; align-items:center; justify-content:flex-start; gap:7px;
        }
        .social-link svg{ width:15px; height:15px; flex-shrink:0; opacity:.7; transition: all .15s ease; }
        .social-link:hover, .social-link.snake-hover{ background:var(--hover-bg); border-color:var(--border-subtle); color:var(--text-primary); }
        .social-link:hover svg, .social-link.snake-hover svg{ opacity:1; }

        /* Background Testimonials - Snake Game */
        .testimonials-bg{
            position:fixed; top:0; left:0; right:0; bottom:0;
            pointer-events:none; z-index:0; overflow:hidden;
            display:flex; flex-direction:column; justify-content:space-around;
            padding:25px 0;
            /* Fade out testimonials in center to keep main content clear */
            mask-image:radial-gradient(ellipse 50% 45% at 50% 50%, transparent 0%, transparent 35%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.3) 60%, rgba(0,0,0,0.6) 70%, black 85%);
            -webkit-mask-image:radial-gradient(ellipse 50% 45% at 50% 50%, transparent 0%, transparent 35%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.3) 60%, rgba(0,0,0,0.6) 70%, black 85%);
            contain:layout style;
        }
        .testimonial-row{
            display:flex; justify-content:center; gap:0; flex-wrap:nowrap;
            white-space:nowrap; overflow:hidden;
            transform:translateZ(0);
            contain:layout style;
        }
        .testimonial-item{
            display:inline-flex; align-items:center; gap:0;
            font-size:.7rem;
            font-family:'Retropix', monospace;
            flex-shrink:0;
        }
        .testimonial-separator{
            margin:0 8px;
        }
        .testimonial-char{
            display:inline-block;
            color:var(--text-hidden);
            transition:color 0.04s linear;
        }
        .testimonial-username{
            font-style:normal; font-weight:500; letter-spacing:0.02em;
        }
        .testimonial-quote{
            font-style:normal; font-weight:400; letter-spacing:0.02em;
        }

        /* Snake Canvas */
        #snake-canvas{
            position:fixed; top:0; left:0; width:100%; height:100%;
            pointer-events:none; z-index:5;
        }

        /* Hidden/Revealed text colors */
        body, body[data-theme="light"]{
            --text-hidden:#fafafa;
            --text-revealed:#555555;
            --snake-color:#111111;
        }
        body[data-theme="dark"]{
            --text-hidden:#0f0f0f;
            --text-revealed:#888888;
            --snake-color:#fafafa;
        }

        .toast{
            position:fixed; bottom:32px; left:50%; transform:translateX(-50%) translateY(80px) scale(0.95);
            background:var(--text-primary); color:var(--bg); padding:12px 24px;
            border-radius:100px; font-size:.85rem; font-weight:500;
            box-shadow:var(--shadow-xl); opacity:0; z-index:2000;
            backdrop-filter:blur(12px); letter-spacing:-.01em;
            transition: all .35s cubic-bezier(.175,.885,.32,1.275);
        }
        .toast.show{ transform:translateX(-50%) translateY(0) scale(1); opacity:1; }

    </style>
</head>
<body data-theme="dark">
    
    <div class="theme-toggle" onclick="toggleTheme()" role="button" aria-label="Toggle dark mode">
        <div class="theme-toggle-circle"></div>
    </div>

    <div class="container">
        <header>
            <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <!-- Background circle -->
                <defs>
                    <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:var(--text-primary);stop-opacity:0.1" />
                        <stop offset="100%" style="stop-color:var(--text-primary);stop-opacity:0.05" />
                    </linearGradient>
                </defs>
                <circle cx="50" cy="50" r="48" fill="url(#logoGradient)" stroke="var(--text-primary)" stroke-width="1.5" opacity="0.3"/>
                
                <!-- Creative code/bracket design -->
                <g fill="none" stroke="var(--text-primary)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <!-- Left bracket -->
                    <path d="M 28 30 L 22 50 L 28 70" opacity="0.8"/>
                    <!-- Right bracket -->
                    <path d="M 72 30 L 78 50 L 72 70" opacity="0.8"/>
                    <!-- Center design - stylized A -->
                    <path d="M 50 25 L 40 65 M 50 25 L 60 65 M 40 45 L 60 45" opacity="0.9" stroke-width="2"/>
                </g>
                
                <!-- Accent dot -->
                <circle cx="50" cy="80" r="2.5" fill="var(--text-primary)" opacity="0.6"/>
            </svg>
            <h1>Anas</h1>
            <p class="hero-statement">
                <span class="static">I</span>
                <span class="typing-wrapper">
                    <span class="typing-text" id="typing-text"></span><span class="cursor"></span>
                </span>
                <span class="static">apps</span>
            </p>
            <div class="tech-badges">
                <span class="badge">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.6 9.48l1.84-3.18c.16-.31.04-.69-.26-.85-.29-.15-.65-.06-.83.22l-1.88 3.24a11.463 11.463 0 00-8.94 0L5.65 5.67c-.19-.29-.55-.38-.84-.22-.3.16-.42.54-.26.85L6.4 9.48A10.78 10.78 0 002 18h20a10.78 10.78 0 00-4.4-8.52zM7 15.25a1.25 1.25 0 110-2.5 1.25 1.25 0 010 2.5zm10 0a1.25 1.25 0 110-2.5 1.25 1.25 0 010 2.5z"/></svg>
                    Android
                </span>
                <span class="badge">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M14.314 0L2.3 12 6 15.7 21.684.013h-7.357zm.014 11.072L7.857 17.53l6.47 6.47H21.7l-6.46-6.468 6.46-6.46h-7.386z"/></svg>
                    Flutter
                </span>
                <span class="badge">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
                    AI
                </span>
            </div>
        </header>

        <div class="divider"></div>

        <nav class="nav-container">
            <div class="nav-item">
                <button class="nav-button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12.01" y2="18"/></svg>
                    Apps
                </button>
                <div class="dropdown">
                    <a href="https://landerpagecreator.github.io/Studio-Mic/" target="_blank" class="dropdown-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                        <span class="item-text">
                            <strong>Studio Mic</strong>
                            <small>Audio Recording Studio</small>
                        </span>
                    </a>
                    <a href="https://landerpagecreator.github.io/TEXTBI/" target="_blank" class="dropdown-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>
                        <span class="item-text">
                            <strong>TEXTBI</strong>
                        </span>
                    </a>
                    <a href="#" class="dropdown-item" onclick="return false;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10v6M2 10l10-5 10 5-10 5z"/><path d="M6 12v5c3 3 9 3 12 0v-5"/></svg>
                        <span class="item-text">
                            <strong>Sunday Tracker</strong>
                            <small>Coming Soon</small>
                        </span>
                    </a>
                </div>
            </div>

            <div class="nav-item">
                <a href="https://github.com/landerpagecreator" target="_blank" class="nav-button">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v 3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
                    GitHub
                </a>
            </div>



            <div class="nav-item">
                <button class="nav-button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/></svg>
                    Hire Me
                </button>
                <div class="dropdown">
                    <a href="https://landerpagecreator.github.io/landerly/" target="_blank" class="dropdown-item">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12.01" y2="18"/></svg>
                        <span class="item-text">
                            <strong>Custom App</strong>
                            <small>Turn your idea into an app</small>
                        </span>
                    </a>
                </div>
            </div>
        </nav>
    </div>

    <!-- Background Testimonials -->
    <div class="testimonials-bg" id="testimonials-bg"></div>

    <!-- Snake Game Canvas -->
    <canvas id="snake-canvas"></canvas>

    <div class="toast" id="toast">Email copied!</div>

    <script>
        // Typewriter Animation
        const words = ['build', 'launch', 'monetise', 'design', 'code', 'ship', ];
        let wordIndex = 0;
        let charIndex = 0;
        let isDeleting = false;
        const typingEl = document.getElementById('typing-text');

        function type() {
            const currentWord = words[wordIndex];

            if (isDeleting) {
                typingEl.textContent = currentWord.substring(0, charIndex - 1);
                charIndex--;
            } else {
                typingEl.textContent = currentWord.substring(0, charIndex + 1);
                charIndex++;
            }

            let typeSpeed = isDeleting ? 60 : 120;

            if (!isDeleting && charIndex === currentWord.length) {
                typeSpeed = 2000;
                isDeleting = true;
            } else if (isDeleting && charIndex === 0) {
                isDeleting = false;
                wordIndex = (wordIndex + 1) % words.length;
                typeSpeed = 400;
            }

            setTimeout(type, typeSpeed);
        }

        setTimeout(type, 600);

        // Load theme from localStorage on page load
        (function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.body.setAttribute('data-theme', savedTheme);
            }
        })();

        function toggleTheme(){
            const body=document.body;
            const next=body.getAttribute('data-theme')==='light'?'dark':'light';
            body.setAttribute('data-theme',next);
            localStorage.setItem('theme',next);
            // Trigger a redraw for theme color updates with slight delay for CSS to apply
            requestAnimationFrame(() => {
                if (window.themeChangeCallback) {
                    window.themeChangeCallback();
                }
            });
        }

        function copyEmail(e){
            e.preventDefault();
            e.stopPropagation();
            navigator.clipboard.writeText('mitchell.h.koh@gmail.com').then(()=>{
                const toast=document.getElementById('toast');
                toast.classList.add('show');
                setTimeout(()=>toast.classList.remove('show'),2000);
            });
        }

        // Mobile touch logic
        document.querySelectorAll('.nav-button').forEach(btn => {
            btn.addEventListener('click', (e) => {
                if(window.innerWidth <= 768) {
                    const item = btn.parentElement;
                    const isActive = item.classList.contains('mobile-active');
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('mobile-active'));
                    if(!isActive) {
                        e.preventDefault();
                        item.classList.add('mobile-active');
                    }
                }
            });
        });

        document.addEventListener('click', (e) => {
            if(!e.target.closest('.nav-item')) {
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('mobile-active'));
            }
        });

        // ==========================================
        // SNAKE GAME - Illuminates Testimonials
        // ==========================================
const backgroundText = [
  [
    "I build systems from ideas that refuse to stay small.",
    "Every project starts with curiosity and ends with something interactive.",
    "Code is not just logic — it’s motion, feedback, and intent.",
    "I design tools that respond in real time, not static concepts."
  ],
  [
    "From audio processing to web applications, I focus on experience.",
    "I like projects that feel alive when you touch them.",
    "Clean architecture matters, but so does how it feels to use.",
    "I turn problems into products, not just solutions."
  ],
  [
    "I work at the edge of code, sound, and interaction.",
    "Real-time systems fascinate me more than static pages.",
    "Every line of code should have a reason to exist.",
    "I care about performance, clarity, and flow."
  ],
  [
    "I experiment fast, break things, then rebuild them better.",
    "Prototypes evolve into polished tools through iteration.",
    "I enjoy building things people didn’t know they needed.",
    "Minimal design, maximum intention."
  ],
  [
    "Some projects start as personal tools and grow into platforms.",
    "I focus on usability before complexity.",
    "Good software should explain itself without instructions.",
    "Details are not extra — they are the product."
  ],
  [
    "I build for creators, developers, and curious minds.",
    "Audio, interfaces, and systems that react instantly.",
    "I enjoy pushing browsers and frameworks past their comfort zones.",
    "Constraints often lead to the best ideas."
  ],
  [
    "I don’t chase trends, I study fundamentals.",
    "Strong foundations allow creative freedom.",
    "Every project teaches me how to build the next one better.",
    "Progress is iterative, not instant."
  ],
  [
    "I care about how users feel when interacting with my work.",
    "Smooth motion is part of communication.",
    "Latency, timing, and feedback shape perception.",
    "Experience is everything."
  ],
  [
    "Some ideas turn into tools, others into experiments.",
    "Not every project needs to be big to be meaningful.",
    "I document, refine, and improve constantly.",
    "Learning never stops when you ship."
  ],
  [
    "I enjoy building systems that scale from simple to complex.",
    "What starts small should grow without breaking.",
    "Readable code is a form of respect.",
    "Maintainability is a feature."
  ],
  [
    "I mix creativity with engineering discipline.",
    "Design choices are made intentionally, not randomly.",
    "I value clarity over cleverness.",
    "Simple done well beats complex done poorly."
  ],
  [
    "Some projects focus on sound, others on interaction.",
    "I like real-time feedback loops.",
    "Instant response creates trust.",
    "Responsiveness defines quality."
  ],
  [
    "I build things I would personally use.",
    "If it feels off, I fix it.",
    "Iteration continues until it feels right.",
    "Good enough is never the goal."
  ],
  [
    "I enjoy working close to the system level.",
    "Understanding how things work makes building easier.",
    "Abstraction is powerful when used carefully.",
    "Control matters."
  ],
  [
    "Every project is a chance to refine my workflow.",
    "Tools improve when builders use them daily.",
    "Real usage exposes real problems.",
    "Feedback drives improvement."
  ],
  [
    "I value speed, but not at the cost of quality.",
    "Optimization starts with understanding.",
    "Measure first, improve second.",
    "Guessing is expensive."
  ],
  [
    "I like interfaces that disappear when used.",
    "Good UX feels natural, not forced.",
    "Motion should guide, not distract.",
    "Silence can be a feature."
  ],
  [
    "I build with intention, not noise.",
    "Every feature earns its place.",
    "Less, but better.",
    "Always refining."
  ]
];


        // Wrap text in character spans for per-character illumination
        function wrapChars(text) {
            return text.split('').map(char =>
                char === ' ' ? '<span class="testimonial-char">&nbsp;</span>' : `<span class="testimonial-char">${char}</span>`
            ).join('');
        }

        // Generate testimonial rows
        const testimonialsBg = document.getElementById('testimonials-bg');

        backgroundText.forEach((row, rowIndex) => {
            const rowEl = document.createElement('div');
            rowEl.className = 'testimonial-row';

            // Stagger row offsets for visual variety
            const offset = (rowIndex % 4) * 80;
            rowEl.style.paddingLeft = offset + 'px';

            row.forEach((testimonial, index) => {
const parts = testimonial.split(' - ');
const username = parts[0];
const quote = parts.slice(1).join(' - ');

                const item = document.createElement('div');
                item.className = 'testimonial-item';

                // Format: @username - "quote text"
                const wrappedUsername = wrapChars(username);
                const wrappedDash = `<span class="testimonial-char">&nbsp;</span><span class="testimonial-char">-</span><span class="testimonial-char">&nbsp;</span>`;
                const wrappedQuote = `<span class="testimonial-char">"</span>${wrapChars(quote)}<span class="testimonial-char">"</span>`;

                item.innerHTML = `<span class="testimonial-username">${wrappedUsername}</span>${wrappedDash}<span class="testimonial-quote">${wrappedQuote}</span>`;
                rowEl.appendChild(item);

                // Add separator dash between testimonials (not after the last one)
                if (index < row.length - 1) {
                    const separator = document.createElement('span');
                    separator.className = 'testimonial-separator';
                    separator.innerHTML = '<span class="testimonial-char">&nbsp;</span><span class="testimonial-char">-</span><span class="testimonial-char">&nbsp;</span>';
                    rowEl.appendChild(separator);
                }
            });

            testimonialsBg.appendChild(rowEl);
        });

        // Snake Game
        const canvas = document.getElementById('snake-canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        // Disable image smoothing for crisp pixel art rendering
        ctx.imageSmoothingEnabled = false;

        const gridSize = 15;
        const snakeLength = 4;
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };

        // Grid dimensions
        let gridCols, gridRows, maxX, maxY, centerCol, centerRow;

        function updateGridDimensions() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Restore context state after resize (canvas resize resets context)
            ctx.imageSmoothingEnabled = false;
            gridCols = Math.floor(canvas.width / gridSize);
            gridRows = Math.floor(canvas.height / gridSize);
            maxX = (gridCols - 1) * gridSize;
            maxY = (gridRows - 1) * gridSize;
            centerCol = Math.floor(gridCols / 2);
            centerRow = Math.floor(gridRows / 2);
        }
        updateGridDimensions();

        // Initialize snake in top half, moving right
        function initSnake() {
            snake = [];
            // Start in upper portion, centered horizontally
            const startX = centerCol * gridSize;
            const startY = Math.floor(gridRows * 0.2) * gridSize;
            for (let i = 0; i < snakeLength; i++) {
                snake.push({ x: startX - i * gridSize, y: startY });
            }
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
        }
        initSnake();

        // Arrow key controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                    e.preventDefault();
                    break;
            }
        });

        let cachedSnakeColor = null;

        function getSnakeColor() {
            if (!cachedSnakeColor) {
                cachedSnakeColor = getComputedStyle(document.body).getPropertyValue('--snake-color').trim();
            }
            return cachedSnakeColor;
        }

        function updateSnakeColor() {
            cachedSnakeColor = getComputedStyle(document.body).getPropertyValue('--snake-color').trim();
        }

        function updateSnake() {
            direction = nextDirection;

            // Calculate new head position
            const head = snake[0];
            let newX = head.x + direction.x * gridSize;
            let newY = head.y + direction.y * gridSize;

            // Wrap around edges (grid-aligned)
            if (newX > maxX) newX = 0;
            if (newX < 0) newX = maxX;
            if (newY > maxY) newY = 0;
            if (newY < 0) newY = maxY;

            // Add new head
            snake.unshift({ x: newX, y: newY });

            // Remove tail
            snake.pop();
        }

        // Food system
        let food = null;
        let isFirstFoodSpawn = true;

        const foodAvoidRadius = 18; // Grid cells to avoid from center (main content area)

        function spawnFood() {
            // First food spawn: middle left area
            if (isFirstFoodSpawn) {
                isFirstFoodSpawn = false;
                // Middle left: left 20%, vertically centered
                const col = Math.floor(gridCols * 0.2);
                const row = Math.floor(gridRows * 0.5);
                food = { x: col * gridSize, y: row * gridSize };
                return;
            }

            // Subsequent spawns: random but avoid center
            for (let attempts = 0; attempts < 100; attempts++) {
                const col = Math.floor(Math.random() * gridCols);
                const row = Math.floor(Math.random() * gridRows);

                // Avoid center area (uses pre-computed centerCol/centerRow)
                if (Math.abs(col - centerCol) + Math.abs(row - centerRow) < foodAvoidRadius) continue;

                const x = col * gridSize;
                const y = row * gridSize;

                // Avoid snake body
                if (snake.some(seg => seg.x === x && seg.y === y)) continue;

                food = { x, y };
                return;
            }
            food = { x: 0, y: 0 }; // Fallback
        }

        function checkFoodCollision() {
            if (!food) return;
            const head = snake[0];
            if (head.x === food.x && head.y === food.y) {
                // Grow snake by adding segment at tail
                const tail = snake[snake.length - 1];
                snake.push({ x: tail.x, y: tail.y });
                spawnFood();
            }
        }

        // Initialize food
        setTimeout(spawnFood, 500);

        let foodPulse = 0;

        function drawSnake(timestamp) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const color = getSnakeColor();
            const size = gridSize - 2;
            const radius = size / 3.5;

            // Draw food with glow effect
            if (food) {
                foodPulse = (timestamp || 0) * 0.004;
                const pulse = 0.9 + Math.sin(foodPulse) * 0.1;
                const glowPulse = 0.4 + Math.sin(foodPulse) * 0.2;

                // Outer glow layers
                ctx.fillStyle = '#4ade80';
                ctx.globalAlpha = glowPulse * 0.15;
                ctx.beginPath();
                ctx.roundRect(food.x - 6, food.y - 6, size + 14, size + 14, radius + 4);
                ctx.fill();

                ctx.fillStyle = '#4ade80';
                ctx.globalAlpha = glowPulse * 0.25;
                ctx.beginPath();
                ctx.roundRect(food.x - 3, food.y - 3, size + 8, size + 8, radius + 2);
                ctx.fill();

                // Main food
                ctx.fillStyle = '#4ade80';
                ctx.globalAlpha = pulse;
                ctx.beginPath();
                ctx.roundRect(food.x + 1, food.y + 1, size, size, radius);
                ctx.fill();

                // Inner highlight
                ctx.fillStyle = '#86efac';
                ctx.globalAlpha = pulse * 0.6;
                ctx.beginPath();
                ctx.roundRect(food.x + 3, food.y + 3, size - 4, size - 4, radius - 1);
                ctx.fill();
            }

            // Draw snake with pixelated grid movement
            snake.forEach((segment, index) => {
                const alpha = 1 - Math.pow(index / Math.max(snake.length - 1, 1), 1.5) * 0.7;
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.roundRect(segment.x + 1, segment.y + 1, size, size, radius);
                ctx.fill();
            });

            ctx.globalAlpha = 1;
        }

        // Get theme colors for interpolation
        function getColors() {
            const style = getComputedStyle(document.body);
            const hidden = style.getPropertyValue('--text-hidden').trim();
            const revealed = style.getPropertyValue('--text-revealed').trim();
            return { hidden, revealed };
        }

        // Parse color to RGB (handles both hex and rgb() formats)
        function parseColor(color) {
            // Try hex format
            const hexResult = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
            if (hexResult) {
                return {
                    r: parseInt(hexResult[1], 16),
                    g: parseInt(hexResult[2], 16),
                    b: parseInt(hexResult[3], 16)
                };
            }
            // Try rgb() format
            const rgbResult = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/.exec(color);
            if (rgbResult) {
                return {
                    r: parseInt(rgbResult[1]),
                    g: parseInt(rgbResult[2]),
                    b: parseInt(rgbResult[3])
                };
            }
            // Fallback
            return { r: 128, g: 128, b: 128 };
        }

        // Interpolate between two colors
        function lerpColor(color1, color2, t) {
            const r = Math.round(color1.r + (color2.r - color1.r) * t);
            const g = Math.round(color1.g + (color2.g - color1.g) * t);
            const b = Math.round(color1.b + (color2.b - color1.b) * t);
            return `rgb(${r},${g},${b})`;
        }

        // Cache character elements for performance
        const charElements = document.querySelectorAll('.testimonial-char');
        const charPositions = [];

        function cacheCharPositions() {
            charPositions.length = 0;
            charElements.forEach(char => {
                const rect = char.getBoundingClientRect();
                charPositions.push({
                    el: char,
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                });
            });
        }
        cacheCharPositions();

        // Cache colors for performance
        let cachedColors = null;
        let cachedHiddenRgb = null;
        let cachedRevealedRgb = null;

        // Pre-compute color strings for each intensity level (0-32 for smooth gradation)
        const colorLevels = 32;
        let colorLookup = [];
        function buildColorLookup() {
            colorLookup = [];
            for (let i = 0; i <= colorLevels; i++) {
                colorLookup.push(lerpColor(cachedHiddenRgb, cachedRevealedRgb, i / colorLevels));
            }
        }

        function updateColorCache() {
            cachedColors = getColors();
            cachedHiddenRgb = parseColor(cachedColors.hidden);
            cachedRevealedRgb = parseColor(cachedColors.revealed);
            updateSnakeColor();
            buildColorLookup();

            // Reset all character colors to new hidden color on theme change
            if (charColorState) charColorState.fill(255);
            charPositions.forEach(({ el }) => {
                el.style.color = colorLookup[0];
            });
        }

        // Set up theme change callback
        window.themeChangeCallback = updateColorCache;

        // Initialize color cache after DOM is ready and theme is set
        // Use double requestAnimationFrame to ensure CSS is fully applied
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                updateColorCache();
            });
        });

        // Illuminate characters near snake and food
        const illuminationRadius = 170;
        const foodIlluminationRadius = 180;
        const illuminationRadiusSq = illuminationRadius * illuminationRadius;
        const foodIlluminationRadiusSq = foodIlluminationRadius * foodIlluminationRadius;

        // Store previous color state to avoid unnecessary DOM updates (Uint8Array is faster than Map for numeric indices)
        let charColorState = null; // Will be initialized after charPositions is populated

        // Pre-allocated array for snake segment centers (avoids per-frame allocation)
        let snakeCenters = new Float32Array(200); // x,y pairs - supports up to 100 segments

        // Initialize color state array
        function initColorState() {
            charColorState = new Uint8Array(charPositions.length);
            // 255 = uninitialized, forces first update
            charColorState.fill(255);
        }
        initColorState();

        function illuminateTestimonials() {
            // Ensure colors are cached
            if (!cachedColors || !cachedHiddenRgb || !cachedRevealedRgb) {
                updateColorCache();
                buildColorLookup();
            }
            if (colorLookup.length === 0) buildColorLookup();

            const halfGrid = gridSize / 2;
            const snakeLen = snake.length;

            // Pre-compute snake segment centers and bounds in one pass
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < snakeLen; i++) {
                const seg = snake[i];
                const cx = seg.x + halfGrid;
                const cy = seg.y + halfGrid;
                snakeCenters[i * 2] = cx;
                snakeCenters[i * 2 + 1] = cy;
                if (cx < minX) minX = cx;
                if (cx > maxX) maxX = cx;
                if (cy < minY) minY = cy;
                if (cy > maxY) maxY = cy;
            }

            // Include food in bounds (fixed calculation)
            const foodCenterX = food ? food.x + halfGrid : 0;
            const foodCenterY = food ? food.y + halfGrid : 0;
            if (food) {
                const foodMinX = foodCenterX - foodIlluminationRadius;
                const foodMaxX = foodCenterX + foodIlluminationRadius;
                const foodMinY = foodCenterY - foodIlluminationRadius;
                const foodMaxY = foodCenterY + foodIlluminationRadius;
                if (foodMinX < minX) minX = foodMinX;
                if (foodMaxX > maxX) maxX = foodMaxX;
                if (foodMinY < minY) minY = foodMinY;
                if (foodMaxY > maxY) maxY = foodMaxY;
            }

            const boundsMinX = minX - illuminationRadius;
            const boundsMaxX = maxX + illuminationRadius;
            const boundsMinY = minY - illuminationRadius;
            const boundsMaxY = maxY + illuminationRadius;

            // Process characters
            const charLen = charPositions.length;
            for (let index = 0; index < charLen; index++) {
                const pos = charPositions[index];
                const x = pos.x, y = pos.y;

                // Quick bounds check
                if (x < boundsMinX || x > boundsMaxX || y < boundsMinY || y > boundsMaxY) {
                    if (charColorState[index] !== 0) {
                        charColorState[index] = 0;
                        pos.el.style.color = colorLookup[0];
                    }
                    continue;
                }

                // Find minimum distance to snake using pre-computed centers
                let minDistSq = Infinity;
                for (let i = 0; i < snakeLen; i++) {
                    const dx = x - snakeCenters[i * 2];
                    const dy = y - snakeCenters[i * 2 + 1];
                    const distSq = dx * dx + dy * dy;
                    if (distSq < minDistSq) minDistSq = distSq;
                    if (distSq < 400) break; // Within ~20px, close enough for full intensity
                }

                // Calculate snake intensity
                let intensity = 0;
                if (minDistSq < illuminationRadiusSq) {
                    intensity = 1 - Math.sqrt(minDistSq) / illuminationRadius;
                }

                // Calculate food intensity
                let foodIntensity = 0;
                if (food) {
                    const dx = x - foodCenterX;
                    const dy = y - foodCenterY;
                    const foodDistSq = dx * dx + dy * dy;
                    if (foodDistSq < foodIlluminationRadiusSq) {
                        foodIntensity = 1 - Math.sqrt(foodDistSq) / foodIlluminationRadius;
                    }
                }

                // Combined intensity with smooth easing
                const combined = Math.max(intensity, foodIntensity);
                // Smoothstep easing for natural illumination (Hermite interpolation)
                const eased = combined > 0 ? combined * combined * (3 - 2 * combined) : 0;
                const quantized = Math.round(eased * colorLevels);

                if (charColorState[index] !== quantized) {
                    charColorState[index] = quantized;
                    pos.el.style.color = colorLookup[quantized];
                }
            }
        }

        // Snake head hover detection
        const navItems = document.querySelectorAll('.nav-item');
        const dropdownItems = document.querySelectorAll('.dropdown-item, .social-link');
        let currentHoveredNav = null;
        let currentHoveredDropdownItem = null;
        let hoverTimeout = null;

        function checkSnakeNavHover() {
            const head = snake[0];
            const hx = head.x + gridSize / 2;
            const hy = head.y + gridSize / 2;

            // Check nav buttons
            let foundNav = null;
            for (const nav of navItems) {
                const r = nav.getBoundingClientRect();
                if (hx >= r.left - 15 && hx <= r.right + 15 && hy >= r.top - 15 && hy <= r.bottom + 15) {
                    foundNav = nav;
                    break;
                }
            }

            // Check if snake is in dropdown area (including gap between button and dropdown)
            let inDropdownArea = false;
            if (currentHoveredNav) {
                const dropdown = currentHoveredNav.querySelector('.dropdown');
                if (dropdown) {
                    const r = dropdown.getBoundingClientRect();
                    // Extend bounds down to include the gap to the button
                    if (hx >= r.left - 10 && hx <= r.right + 10 && hy >= r.top - 10 && hy <= r.bottom + 50) {
                        inDropdownArea = true;
                    }
                }
            }

            // Check dropdown items (only visible ones)
            let foundItem = null;
            for (const item of dropdownItems) {
                const r = item.getBoundingClientRect();
                if (r.width === 0) continue;
                if (hx >= r.left && hx <= r.right && hy >= r.top && hy <= r.bottom) {
                    foundItem = item;
                    break;
                }
            }

            // Update dropdown item hover
            if (foundItem !== currentHoveredDropdownItem) {
                if (currentHoveredDropdownItem) currentHoveredDropdownItem.classList.remove('snake-hover');
                if (foundItem) foundItem.classList.add('snake-hover');
                currentHoveredDropdownItem = foundItem;
            }

            // Update nav hover
            if (foundNav !== currentHoveredNav) {
                if (hoverTimeout) { clearTimeout(hoverTimeout); hoverTimeout = null; }
                if (foundNav) {
                    if (currentHoveredNav) currentHoveredNav.classList.remove('snake-hover');
                    foundNav.classList.add('snake-hover');
                    currentHoveredNav = foundNav;
                } else if (!foundItem && !inDropdownArea) {
                    const toRemove = currentHoveredNav;
                    hoverTimeout = setTimeout(() => {
                        if (toRemove) toRemove.classList.remove('snake-hover');
                        if (currentHoveredNav === toRemove) currentHoveredNav = null;
                    }, 300);
                    currentHoveredNav = null;
                }
            }
        }

        // Game loop with smooth timing
        let lastUpdate = 0;
        let lastIllumination = 0;
        const updateInterval = 70; // Snake speed (lower = faster)
        const illuminationInterval = 50; // Illumination update rate (let CSS transitions handle smoothing)

        function gameLoop(timestamp) {
            if (timestamp - lastUpdate >= updateInterval) {
                updateSnake();
                checkFoodCollision();
                lastUpdate = timestamp;
            }
            drawSnake(timestamp);
            // Throttle illumination updates to let CSS transitions create smooth animations
            if (timestamp - lastIllumination >= illuminationInterval) {
                illuminateTestimonials();
                lastIllumination = timestamp;
            }
            checkSnakeNavHover();
            requestAnimationFrame(gameLoop);
        }

        // Start game loop after a brief delay for smooth initialization
        setTimeout(() => requestAnimationFrame(gameLoop), 100);

        // Debounced resize handler - consolidates all resize logic
        let resizeTimeout = null;
        window.addEventListener('resize', () => {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateGridDimensions();
                cacheCharPositions();
                initColorState(); // Reinitialize color state array for new char positions
                initSnake();
                isFirstFoodSpawn = true; // Reset flag so food spawns in middle left
                spawnFood();
                // Clear snake hover states
                if (currentHoveredNav) {
                    currentHoveredNav.classList.remove('snake-hover');
                    currentHoveredNav = null;
                }
                if (currentHoveredDropdownItem) {
                    currentHoveredDropdownItem.classList.remove('snake-hover');
                    currentHoveredDropdownItem = null;
                }
            }, 150);
        });
    </script>
</body>
</html>
